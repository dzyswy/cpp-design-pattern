# cpp-design-pattern
c++ 设计模式        

<br>
<br>

# 1. 设计模式分类和意图
   
## 1.1 创建型模式：
创建对象的机制，从所需要实例化的对象中解耦。        
|设计模式名称|说明|
|-----------|-----------|
|简单工厂模式(Simple Factory)|提供了一个静态方法来创建产品对象，而不需要暴露复杂的实现。|
|工厂方法模式 (Factory)|定义一个创建对象的接口，让子类决定实例化哪一个类。|
|抽象工厂模式 (Abstract Factory)|提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。|
|建造者模式 (Builder)|将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。|
|原型模式 (Prototype)|用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。|
|单例模式 (Singleton)|确保一个类仅有一个实例，并提供一个访问它的全局访问点。|
<br>

## 1.2 结构型模式：
将对象或类组装到更大的结构中。          
|设计模式名称|说明|
|-----------|-----------|
|装饰器模式 (Decorator)|动态地给一个对象添加一些额外的职责。|
|外观模式 (Facade)|为子系统中的一组接口提供一个一致的界面。|
|组合模式 (Composite)|将对象组合成树形结构以表示“部分-整体”的层次结构。|
|享元模式 (Flyweight)|运用共享技术有效地支持大量细粒度的对象。|
|代理模式 (Proxy)|为其他对象提供一种代理以控制对这个对象的访问。|
|适配器模式 (Adapter)|将一个类的接口转换成客户希望的另一个接口。|
|桥接模式 (Bridge)|将抽象部分与它的实现部分分离，使它们都可以独立地变化。|
<br>

## 1.3 行为模式：
负责对象间的交互和分配职责。        
|设计模式名称|说明|
|-----------|-----------|
|模板方法(Template)模式|定义了一个算法的骨架，并允许子类为一个或多个步骤提供具体的实现。|
|策略模式 (Strategy)|定义了一系列算法，并将每一个算法封装起来，使它们可以互相替换。|
|观察者模式 (Observer)|当对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。|
|命令模式 (Command)|将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。|
|迭代器模式 (Iterator)|提供一种方法来访问一个聚合对象的元素，而无需暴露该对象的内部表示。|
|状态模式 (State)|允许一个对象在其内部状态改变时改变它的行为。|
|中介者模式 (Mediator)|用一个中介对象来封装一系列的对象交互。|
|备忘录模式 (Memento)|在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。|
|职责链模式 (Chain of Responsibility)|使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。|
|访问者模式 (Visitor)|表示一个作用于某对象结构中的各元素的操作。|
|解释器模式 (Interpreter)|给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。|
<br>

# 2. 面向对象设计要素
|要素|说明|
|-----------|-----------|
| 对象（Objects）：|对象是面向对象设计的基本单元，它封装了数据和操作数据的函数（方法）。每个对象都有其状态（属性）和行为（方法）。|
| 类（Classes）：|类是对象的蓝图或模板，它定义了对象的属性和方法。类可以创建多个对象，这些对象共享类的属性和方法。|
| 封装（Encapsulation）：|封装是将对象的属性和方法的实现细节隐藏起来，只对外公开一个可以操作的接口。这样可以保护对象内部的状态，防止外部直接访问和修改。|
| 继承（Inheritance）：|继承是面向对象编程的一个特性，它允许一个类（子类）继承另一个类（父类）的属性和方法。继承可以促进代码的重用和模块化。|
| 多态（Polymorphism）：|多态是指不同的对象可以响应相同的消息（方法调用），但根据对象的不同，执行不同的操作。多态可以通过继承和接口实现。针对接口编程，不针对实现编程。（交通工具->汽车，轮船，火车）（运行时绑定，不是编译时绑定）|
| 接口（Interfaces）：|接口定义了一组抽象的API，它规定了类应该实现的方法。通过接口，可以实现多态和代码解耦。|
| 组合（Composition）：|组合是一种设计原则，它通过将一个对象包含在另一个对象中来创建复杂对象。组合与继承不同，它不是类型之间的继承关系，而是对象之间的包含关系。|
| 抽象（Abstraction）：|抽象是隐藏复杂细节，只展示必要信息的过程。在面向对象设计中，抽象可以帮助开发者专注于对象的高层次概念，而不是底层的实现细节。|
| 设计模式（Design Patterns）：|设计模式是针对特定问题的通用解决方案。它们提供了一种在面向对象设计中重用和共享经验的途径。|
| 原则（Principles）：|如SOLID原则（单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则）等，这些原则指导开发者如何设计可维护、可扩展和可复用的代码。|
<br>


# 3. 面向对象设计原则

* 单一职责原则：一个类应该只有一个引起它变化的原因。这意味着类应该具有明确的责任和功能。
* 开放封闭原则：软件实体应该是可扩展的，但是不可修改的。即可以通过添加新的代码来扩展功能，而不是修改现有的代码。
* 里氏替换原则：子类必须能够替换它们的基类。这意味着子类应该能够在不破坏程序正确性的前提下替换基类。
* 接口隔离原则：客户端不应该被迫依赖它不使用的方法。即一个类不应该被强制实现它不需要的接口。
* 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。


<br>


# 4. 类之间的关系
依赖：（偶然的，陌生的）   你和某个服务员的关系     
关联：（必然的，熟悉的）   你和某个朋友的关系       

聚合：（has a）           团队和成员的关系，某个成员立刻，不会导致团队的解散        
组合：（has a & part of） 人和某个器官的关系，生命周期，人死了，身体的器官也没有存在意义了。        

实现：（is a 接口）       接口，拥有未定义的虚函数，无法直接例化        
继承：（is a 父类）       父类，有虚函数，可例化        

<br>



1. 简介

观察者模式（Observer Pattern）是一种常用的设计模式，属于行为型模式。它定义了一种一对多的依赖关系，使得当一个对象（主题）状态发生变化时，所有依赖于它的对象（观察者）都会得到通知并自动更新。

引入“观察者”设计模式的定义（实现意图）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会自动得到通知。

主要组成部分
主题（Subject）：也叫观察目标，指被观察的对象。维护观察者列表，提供添加、删除观察者的方法。当状态变化时，通知所有的观察者。
观察者（Observer）：定义一个更新接口，以便主题在状态变化时调用。每个观察者都可以根据主题的变化更新自身状态。
具体主题（ConcreteSubject）：实现主题的接口，维护具体的状态。在状态变化时，调用通知方法来更新所有观察者。
具体观察者（ConcreteObserver）：实现观察者接口，更新自身状态以反映主题的变化。每个观察者可以根据主题的状态执行特定的操作。
 
2. 适用场景


适用场景
事件处理系统：GUI框架中，用户操作（如点击按钮）会触发事件，多个组件需要对这些事件做出反应。
数据绑定：在MVC（模型-视图-控制器）架构中，当模型数据变化时，视图需要自动更新以反映最新的数据。
发布-订阅系统：在消息传递系统中，多个订阅者会对特定主题的消息做出反应，发布者只需发布消息而不需要关心订阅者的具体实现。
状态监控：在监控系统中，多个观察者需要监控同一状态（如温度传感器的读数），当状态变化时，所有观察者都能及时获取更新。
社交媒体通知：当用户发布新内容时，所有关注该用户的粉丝会收到更新通知。
 

3. 优缺点
优点：
松耦合：观察者和主题之间的关系是松散的，降低了模块间的耦合度。
动态添加观察者：可以在运行时增加或减少观察者。
多对一的通知：一个主题可以通知多个观察者，适合事件驱动的场景。

缺点：
通知开销：如果观察者数量较多，通知开销可能较大。
循环依赖：若观察者和主题相互依赖，可能导致循环更新。
